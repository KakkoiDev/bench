#!/bin/sh
# bench - Minimal benchmarking CLI
# POSIX-compliant shell script (dash-compatible)

set -e

VERSION="2.0.0"
SCHEMA_VERSION="2.0"

# Global state for signal handling
INTERRUPTED=0
RUNS_COMPLETED=0
OUTPUT_DIR=""

# Error handling
error() {
  echo "Error: $1" >&2
  exit 1
}

# Show version
show_version() {
  echo "bench v${VERSION}"
  exit 0
}

# Show help
show_help() {
  cat << 'EOF'
Usage: bench [OPTIONS] COMMAND

Minimal benchmarking CLI - Run commands multiple times and capture structured data.

Options:
  --runs N          Number of runs (default: 10)
  --name NAME       Named group for organizing results
  --message TEXT    Describe what changed (e.g., "baseline", "with cache")
  --quiet           Suppress progress output, only print results path

  --pid PID         Monitor process CPU/memory by PID
  --port PORT       Monitor process by port (auto-resolves PID)

  --help            Show help
  --version         Show version

Examples:
  bench --runs 10 "curl localhost:8080"
  bench --runs 20 --name "api-v1" --message "baseline" "curl localhost/api"
  bench --runs 50 --pid 12345 "curl localhost:8080"

Output:
  Results saved to: ./bench-results/<name>/<timestamp-pid>/
    - benchmark.json (all metrics)
    - runs/*.log (individual run outputs)

More info:
  https://github.com/KakkoiDev/bench
  https://github.com/KakkoiDev/bench/issues

EOF
  exit 0
}

# Signal handler for SIGINT/SIGTERM (invoked via trap)
# shellcheck disable=SC2329
handle_interrupt() {
  INTERRUPTED=1
}

# Get current time in seconds with microsecond precision
get_time() {
  perl -MTime::HiRes=time -e 'printf "%.6f\n", time()'
}

# Get ISO 8601 timestamp with milliseconds
get_iso_timestamp() {
  perl -MTime::HiRes=gettimeofday -MPOSIX=strftime -e '
    my ($s, $us) = gettimeofday();
    my $ms = int($us / 1000);
    print strftime("%Y-%m-%dT%H:%M:%S", localtime($s)) . sprintf(".%03d", $ms) . "\n";
  '
}

# Normalize bc output to always have leading zero
bc_normalize() {
  echo "$1" | bc | sed 's/^\./0./; s/^-\./-0./'
}

# Generate auto-name from command
# Algorithm: Remove quotes/special chars → lowercase → spaces to dashes → remove consecutive dashes → truncate 50 → trim trailing dashes
# Falls back to "benchmark" if result is empty (e.g., command is all special chars)
generate_name() {
  name=$(echo "$1" | \
    tr -cd 'a-zA-Z0-9 -' | \
    tr '[:upper:]' '[:lower:]' | \
    tr ' ' '-' | \
    sed 's/--*/-/g' | \
    cut -c1-50 | \
    sed 's/-$//')
  if [ -z "$name" ]; then
    echo "benchmark"
  else
    echo "$name"
  fi
}

# Check dependencies
check_dependencies() {
  # Check for perl
  if ! command -v perl >/dev/null 2>&1; then
    error "Required dependency 'perl' not found. Please install perl."
  fi

  # Check for bc
  if ! command -v bc >/dev/null 2>&1; then
    error "Required dependency 'bc' not found. Please install bc."
  fi

  # Check for Time::HiRes module
  if ! perl -MTime::HiRes -e 'exit 0' 2>/dev/null; then
    error "Required Perl module 'Time::HiRes' not found. Please install libtime-hires-perl or equivalent."
  fi
}

# Get process stats (CPU%, memory in MB) using ps
# Returns: "cpu_percent memory_mb" or empty if process not found
get_process_stats() {
  pid="$1"
  if [ -z "$pid" ] || ! kill -0 "$pid" 2>/dev/null; then
    echo ""
    return
  fi
  # ps output: %CPU %MEM RSS (in KB)
  # Convert RSS to MB
  stats=$(ps -p "$pid" -o %cpu=,%mem=,rss= 2>/dev/null | tail -1)
  if [ -n "$stats" ]; then
    cpu=$(echo "$stats" | awk '{print $1}')
    rss_kb=$(echo "$stats" | awk '{print $3}')
    mem_mb=$(echo "scale=2; $rss_kb / 1024" | bc)
    echo "$cpu $mem_mb"
  else
    echo ""
  fi
}

# Get process name from ps
# Returns: process command name or empty if not found
get_process_name() {
  pid="$1"
  if [ -z "$pid" ] || ! kill -0 "$pid" 2>/dev/null; then
    echo ""
    return
  fi
  ps -p "$pid" -o comm= 2>/dev/null | head -1
}

# Resolve port to PID using lsof (with timeout to prevent hanging)
resolve_port_to_pid() {
  port="$1"
  # Use timeout if available (3 seconds max)
  timeout_cmd=""
  if command -v timeout >/dev/null 2>&1; then
    timeout_cmd="timeout 3"
  fi

  if command -v lsof >/dev/null 2>&1; then
    $timeout_cmd lsof -ti :"$port" -sTCP:LISTEN 2>/dev/null | head -1
  elif command -v ss >/dev/null 2>&1; then
    # Fallback to ss
    $timeout_cmd ss -tlnp 2>/dev/null | grep ":$port " | sed -n 's/.*pid=\([0-9]*\).*/\1/p' | head -1
  else
    echo ""
  fi
}

# Main entry point
main() {
  # Default values
  RUNS=10
  NAME=""
  MESSAGE=""
  QUIET=0
  MONITOR_PROCESSES=""  # Space-separated list of "name:pid:port" entries
  COMMAND=""

  # Parse arguments
  while [ $# -gt 0 ]; do
    case "$1" in
      --version)
        show_version
        ;;
      --help)
        show_help
        ;;
      --runs)
        shift
        if [ -z "$1" ]; then
          error "--runs requires an argument"
        fi
        # Validate numeric
        case "$1" in
          ''|*[!0-9]*)
            error "--runs requires a numeric argument"
            ;;
        esac
        # Validate positive
        if [ "$1" -le 0 ]; then
          error "--runs must be a positive number (at least 1)"
        fi
        # Pre-flight disk space check for large runs (estimate 10MB per run)
        if [ "$1" -gt 10000 ]; then
          # Get available disk space in KB
          available_kb=$(df -k . 2>/dev/null | awk 'NR==2 {print $4}')
          if [ -n "$available_kb" ]; then
            # Estimate needed: runs * 10MB = runs * 10240 KB
            needed_kb=$((${1} * 10240 / 1000))
            if [ "$available_kb" -lt "$needed_kb" ]; then
              error "Insufficient disk space for $1 runs (need ~$((needed_kb / 1024))MB, have ~$((available_kb / 1024))MB)"
            fi
          fi
        fi
        RUNS="$1"
        shift
        ;;
      --name)
        shift
        if [ -z "$1" ]; then
          error "--name requires an argument"
        fi
        # Validate length (max 255 chars)
        if [ "${#1}" -gt 255 ]; then
          error "--name must be 255 characters or less"
        fi
        NAME="$1"
        shift
        ;;
      --message)
        shift
        if [ -z "$1" ]; then
          error "--message requires an argument"
        fi
        # Validate length (max 1000 chars)
        if [ "${#1}" -gt 1000 ]; then
          error "--message must be 1000 characters or less"
        fi
        MESSAGE="$1"
        shift
        ;;
      --quiet)
        QUIET=1
        shift
        ;;
      --pid)
        shift
        if [ -z "$1" ]; then
          error "--pid requires an argument"
        fi
        # Parse name:pid or just pid format
        case "$1" in
          *:*)
            # name:pid format
            proc_name="${1%%:*}"
            proc_pid="${1#*:}"
            ;;
          *)
            # Just pid, name will be auto-detected later
            proc_name=""
            proc_pid="$1"
            ;;
        esac
        # Validate PID is numeric
        case "$proc_pid" in
          ''|*[!0-9]*)
            error "--pid requires a numeric PID (got: $proc_pid)"
            ;;
        esac
        # Add to monitor list (name:pid:port format, port empty for --pid)
        MONITOR_PROCESSES="$MONITOR_PROCESSES $proc_name:$proc_pid:"
        shift
        ;;
      --port)
        shift
        if [ -z "$1" ]; then
          error "--port requires an argument"
        fi
        # Parse name:port or just port format
        case "$1" in
          *:*)
            # name:port format
            proc_name="${1%%:*}"
            proc_port="${1#*:}"
            ;;
          *)
            # Just port, name will be auto-detected later
            proc_name=""
            proc_port="$1"
            ;;
        esac
        # Validate port is numeric
        case "$proc_port" in
          ''|*[!0-9]*)
            error "--port requires a numeric port (got: $proc_port)"
            ;;
        esac
        # Resolve port to PID
        resolved_pid=$(resolve_port_to_pid "$proc_port")
        if [ -z "$resolved_pid" ]; then
          error "No process found listening on port $proc_port"
        fi
        # Add to monitor list (name:pid:port format)
        MONITOR_PROCESSES="$MONITOR_PROCESSES $proc_name:$resolved_pid:$proc_port"
        shift
        ;;
      --)
        shift
        COMMAND="$*"
        break
        ;;
      -*)
        error "Unknown option: $1"
        ;;
      *)
        COMMAND="$*"
        break
        ;;
    esac
  done

  # Validate command provided
  if [ -z "$COMMAND" ]; then
    error "Command required. Use --help for usage information."
  fi

  # Check dependencies
  check_dependencies

  # Trim leading space from MONITOR_PROCESSES
  MONITOR_PROCESSES=$(echo "$MONITOR_PROCESSES" | sed 's/^ *//')

  # Process and validate monitored processes
  if [ -n "$MONITOR_PROCESSES" ]; then
    validated_processes=""
    seen_names=""
    name_counter=1

    for entry in $MONITOR_PROCESSES; do
      proc_name="${entry%%:*}"
      rest="${entry#*:}"
      proc_pid="${rest%%:*}"
      proc_port="${rest#*:}"

      # Validate PID exists
      if ! kill -0 "$proc_pid" 2>/dev/null; then
        error "Process $proc_pid does not exist"
      fi

      # Auto-detect name if not provided
      if [ -z "$proc_name" ]; then
        proc_name=$(get_process_name "$proc_pid")
        if [ -z "$proc_name" ]; then
          proc_name="process-$proc_pid"
        fi
        # Handle duplicate auto-detected names by appending suffix
        base_name="$proc_name"
        while echo "$seen_names" | grep -qw "$proc_name"; do
          name_counter=$((name_counter + 1))
          proc_name="${base_name}-${name_counter}"
        done
      else
        # Check for duplicate user-provided names
        if echo "$seen_names" | grep -qw "$proc_name"; then
          error "Duplicate process name: $proc_name"
        fi
      fi

      seen_names="$seen_names $proc_name"
      validated_processes="$validated_processes $proc_name:$proc_pid:$proc_port"
    done

    MONITOR_PROCESSES=$(echo "$validated_processes" | sed 's/^ *//')
  fi

  # Auto-generate name if not provided
  if [ -z "$NAME" ]; then
    NAME=$(generate_name "$COMMAND")
  fi

  # Create output directory: ./bench-results/<name>/YYYYMMDD-HHMMSS-PID/
  timestamp=$(date '+%Y%m%d-%H%M%S')
  OUTPUT_DIR="./bench-results/${NAME}/${timestamp}-$$"
  mkdir -p "$OUTPUT_DIR/runs"

  # Setup signal handlers
  trap 'handle_interrupt' INT TERM

  # Disable exit on error for benchmark loop (we track failures ourselves)
  set +e

  # Run benchmark loop
  run_num=1
  times_file=$(mktemp)
  exit_codes_file=$(mktemp)
  runs_file=$(mktemp)

  # Capture initial metrics for all monitored processes (for leak detection)
  initial_metrics=""
  if [ -n "$MONITOR_PROCESSES" ]; then
    for entry in $MONITOR_PROCESSES; do
      proc_name="${entry%%:*}"
      rest="${entry#*:}"
      proc_pid="${rest%%:*}"

      initial_stats=$(get_process_stats "$proc_pid")
      if [ -n "$initial_stats" ]; then
        initial_mem=$(echo "$initial_stats" | awk '{print $2}')
      else
        initial_mem=0
      fi
      initial_metrics="$initial_metrics $proc_name:$initial_mem"
    done
    initial_metrics=$(echo "$initial_metrics" | sed 's/^ *//')
  fi

  if [ "$QUIET" -eq 0 ]; then
    echo "Running '$COMMAND' $RUNS times..." >&2
  fi

  while [ "$run_num" -le "$RUNS" ] && [ "$INTERRUPTED" -eq 0 ]; do
    if [ "$QUIET" -eq 0 ]; then
      printf "\r  Run %d/%d" "$run_num" "$RUNS" >&2
    fi

    # Capture timestamps and timing
    start_iso=$(get_iso_timestamp)
    start_time=$(get_time)

    # Run command in background to allow signal handling
    # Capture stdout and stderr separately
    stdout_file="$OUTPUT_DIR/runs/${run_num}.stdout"
    stderr_file="$OUTPUT_DIR/runs/${run_num}.stderr"
    sh -c "$COMMAND" > "$stdout_file" 2> "$stderr_file" &
    cmd_pid=$!
    wait $cmd_pid 2>/dev/null
    cmd_exit=$?

    end_time=$(get_time)
    end_iso=$(get_iso_timestamp)

    # Check for interrupt after each run
    if [ "$INTERRUPTED" -eq 1 ]; then
      # Kill any remaining child process
      kill $cmd_pid 2>/dev/null || true
      break
    fi

    # Calculate durations
    duration_ms=$(bc_normalize "scale=6; ($end_time - $start_time) * 1000")
    duration_sec=$(bc_normalize "scale=6; $end_time - $start_time")

    # Get output sizes
    stdout_bytes=$(wc -c < "$stdout_file")
    stderr_bytes=$(wc -c < "$stderr_file")

    # Combine stdout/stderr into single log for backwards compatibility
    cat "$stdout_file" "$stderr_file" > "$OUTPUT_DIR/runs/${run_num}.log"

    # Capture metrics for all monitored processes
    processes_json=""
    if [ -n "$MONITOR_PROCESSES" ]; then
      timestamp_now=$(get_iso_timestamp)
      first_proc=1
      for entry in $MONITOR_PROCESSES; do
        proc_name="${entry%%:*}"
        rest="${entry#*:}"
        proc_pid="${rest%%:*}"

        server_stats=$(get_process_stats "$proc_pid")
        if [ -n "$server_stats" ]; then
          run_cpu=$(echo "$server_stats" | awk '{print $1}')
          run_mem=$(echo "$server_stats" | awk '{print $2}')

          # Write to per-process metrics file
          echo "$timestamp_now cpu:${run_cpu}% mem:${run_mem}MB" >> "$OUTPUT_DIR/runs/${run_num}.${proc_name}.metrics"

          # Build JSON for this process
          if [ "$first_proc" -eq 1 ]; then
            first_proc=0
          else
            processes_json="$processes_json,"
          fi
          processes_json="$processes_json\"$proc_name\":{\"cpu_percent\":$run_cpu,\"memory_mb\":$run_mem}"
        fi
      done
    fi

    # Store per-run data as JSON line
    processes_field=""
    if [ -n "$processes_json" ]; then
      processes_field=",\"processes\":{$processes_json}"
    fi
    echo "{\"run_number\":$run_num,\"exit_code\":$cmd_exit,\"start\":\"$start_iso\",\"end\":\"$end_iso\",\"duration_seconds\":$duration_sec,\"duration_ms\":$duration_ms,\"stdout_bytes\":$stdout_bytes,\"stderr_bytes\":$stderr_bytes$processes_field}" >> "$runs_file"

    # Store results for statistics
    echo "$duration_ms" >> "$times_file"
    echo "$cmd_exit" >> "$exit_codes_file"

    RUNS_COMPLETED=$run_num
    run_num=$((run_num + 1))
  done

  if [ "$QUIET" -eq 0 ]; then
    echo "" >&2
  fi

  # Re-enable exit on error
  set -e

  # Calculate statistics
  runs_successful=0
  runs_failed=0
  while IFS= read -r code; do
    if [ "$code" -eq 0 ]; then
      runs_successful=$((runs_successful + 1))
    else
      runs_failed=$((runs_failed + 1))
    fi
  done < "$exit_codes_file"

  # Calculate timing statistics
  if [ "$RUNS_COMPLETED" -gt 0 ]; then
    # Sort times for median/percentiles
    sorted_times=$(sort -n "$times_file")

    # Min/Max
    time_min=$(echo "$sorted_times" | head -1)
    time_max=$(echo "$sorted_times" | tail -1)

    # Mean
    time_sum=$(awk '{sum+=$1} END {printf "%.6f", sum}' "$times_file")
    time_mean=$(bc_normalize "scale=6; $time_sum / $RUNS_COMPLETED")

    # Median
    mid=$((RUNS_COMPLETED / 2))
    if [ $((RUNS_COMPLETED % 2)) -eq 0 ]; then
      val1=$(echo "$sorted_times" | sed -n "${mid}p")
      val2=$(echo "$sorted_times" | sed -n "$((mid + 1))p")
      time_median=$(bc_normalize "scale=6; ($val1 + $val2) / 2")
    else
      time_median=$(echo "$sorted_times" | sed -n "$((mid + 1))p")
    fi

    # Standard deviation (sample stddev with n-1 denominator)
    # Formula: sqrt(sum((x - mean)^2) / (n - 1))
    if [ "$RUNS_COMPLETED" -gt 1 ]; then
      sum_sq_diff=$(awk -v mean="$time_mean" '{diff=$1-mean; sum+=diff*diff} END {printf "%.6f", sum}' "$times_file")
      time_stddev=$(bc_normalize "scale=6; sqrt($sum_sq_diff / ($RUNS_COMPLETED - 1))")
    else
      time_stddev=0
    fi

    # Percentiles using nearest rank method
    # Formula: rank = ceil(percentile * n)
    # p95
    p95_rank=$(echo "scale=0; ($RUNS_COMPLETED * 95 + 99) / 100" | bc)
    [ "$p95_rank" -gt "$RUNS_COMPLETED" ] && p95_rank=$RUNS_COMPLETED
    time_p95=$(echo "$sorted_times" | sed -n "${p95_rank}p")

    # p99
    p99_rank=$(echo "scale=0; ($RUNS_COMPLETED * 99 + 99) / 100" | bc)
    [ "$p99_rank" -gt "$RUNS_COMPLETED" ] && p99_rank=$RUNS_COMPLETED
    time_p99=$(echo "$sorted_times" | sed -n "${p99_rank}p")
  else
    time_min=0
    time_max=0
    time_mean=0
    time_median=0
    time_stddev=0
    time_p95=0
    time_p99=0
  fi

  # Calculate success rate
  if [ "$RUNS_COMPLETED" -gt 0 ]; then
    success_rate=$(bc_normalize "scale=2; $runs_successful * 100 / $RUNS_COMPLETED")
  else
    success_rate=0
  fi

  # Calculate aggregate process metrics if monitoring
  processes_json=""
  if [ -n "$MONITOR_PROCESSES" ]; then
    processes_json=",
  \"processes\": ["
    first_proc=1

    for entry in $MONITOR_PROCESSES; do
      proc_name="${entry%%:*}"
      rest="${entry#*:}"
      proc_pid="${rest%%:*}"
      proc_port="${rest#*:}"

      # Get initial memory from saved initial_metrics
      initial_mem=0
      for im in $initial_metrics; do
        im_name="${im%%:*}"
        im_mem="${im#*:}"
        if [ "$im_name" = "$proc_name" ]; then
          initial_mem="$im_mem"
          break
        fi
      done

      # Get final memory for leak detection
      final_stats=$(get_process_stats "$proc_pid")
      if [ -n "$final_stats" ]; then
        final_mem=$(echo "$final_stats" | awk '{print $2}')
      else
        final_mem="$initial_mem"
      fi
      mem_delta=$(bc_normalize "scale=2; $final_mem - $initial_mem")

      # Calculate CPU and memory stats from per-run metrics files
      metrics_files=$(find "$OUTPUT_DIR/runs" -name "*.${proc_name}.metrics" 2>/dev/null)
      if [ -n "$metrics_files" ]; then
        # Extract cpu and mem values from metrics files
        # Format: "2025-01-30T14:30:52 cpu:15.2% mem:45.0MB"
        # shellcheck disable=SC2086
        cpu_values=$(cat $metrics_files 2>/dev/null | sed 's/.*cpu:\([0-9.]*\)%.*/\1/')
        # shellcheck disable=SC2086
        mem_values=$(cat $metrics_files 2>/dev/null | sed 's/.*mem:\([0-9.]*\)MB.*/\1/')

        if [ -n "$cpu_values" ]; then
          cpu_mean=$(echo "$cpu_values" | awk '{sum+=$1; count++} END {if(count>0) printf "%.2f", sum/count; else print "0"}')
          cpu_min=$(echo "$cpu_values" | awk 'NR==1{min=$1} {if($1<min)min=$1} END{printf "%.2f", min}')
          cpu_max=$(echo "$cpu_values" | awk 'NR==1{max=$1} {if($1>max)max=$1} END{printf "%.2f", max}')
        else
          cpu_mean=0
          cpu_min=0
          cpu_max=0
        fi

        if [ -n "$mem_values" ]; then
          mem_mean=$(echo "$mem_values" | awk '{sum+=$1; count++} END {if(count>0) printf "%.2f", sum/count; else print "0"}')
          mem_min=$(echo "$mem_values" | awk 'NR==1{min=$1} {if($1<min)min=$1} END{printf "%.2f", min}')
          mem_max=$(echo "$mem_values" | awk 'NR==1{max=$1} {if($1>max)max=$1} END{printf "%.2f", max}')
        else
          mem_mean=0
          mem_min=0
          mem_max=0
        fi
      else
        cpu_mean=0
        cpu_min=0
        cpu_max=0
        mem_mean=0
        mem_min=0
        mem_max=0
      fi

      # Add comma separator for subsequent entries
      if [ "$first_proc" -eq 1 ]; then
        first_proc=0
      else
        processes_json="$processes_json,"
      fi

      # Build port field only if port was specified
      port_field=""
      if [ -n "$proc_port" ]; then
        port_field="
      \"port\": $proc_port,"
      fi

      processes_json="$processes_json
    {
      \"name\": \"$proc_name\",
      \"pid\": $proc_pid,$port_field
      \"cpu\": {
        \"unit\": \"percent\",
        \"mean\": $cpu_mean,
        \"min\": $cpu_min,
        \"max\": $cpu_max
      },
      \"memory\": {
        \"unit\": \"megabytes\",
        \"mean\": $mem_mean,
        \"min\": $mem_min,
        \"max\": $mem_max,
        \"initial\": $initial_mem,
        \"final\": $final_mem,
        \"delta\": $mem_delta
      }
    }"
    done

    processes_json="$processes_json
  ]"
  fi

  # Build runs array from temp file
  runs_json="["
  first=1
  while IFS= read -r line; do
    if [ "$first" -eq 1 ]; then
      first=0
    else
      runs_json="$runs_json,"
    fi
    runs_json="$runs_json
    $line"
  done < "$runs_file"
  runs_json="$runs_json
  ]"

  # Generate JSON output
  cat > "$OUTPUT_DIR/benchmark.json" << ENDJSON
{
  "schema_version": "$SCHEMA_VERSION",
  "tool": "bench",
  "tool_version": "$VERSION",
  "name": "$NAME",
  "message": "$MESSAGE",
  "command": "$COMMAND",
  "runs_requested": $RUNS,
  "runs_completed": $RUNS_COMPLETED,
  "runs_successful": $runs_successful,
  "runs_failed": $runs_failed,
  "success_rate": $success_rate,
  "interrupted": $([ "$INTERRUPTED" -eq 1 ] && echo "true" || echo "false"),
  "timing": {
    "unit": "milliseconds",
    "min": $time_min,
    "max": $time_max,
    "mean": $time_mean,
    "median": $time_median,
    "stddev": $time_stddev,
    "p95": $time_p95,
    "p99": $time_p99
  },
  "environment": {
    "os": "$(uname -s)",
    "shell": "$SHELL",
    "pwd": "$PWD"
  },
  "runs": $runs_json$processes_json
}
ENDJSON

  # Cleanup temp files
  rm -f "$times_file" "$exit_codes_file" "$runs_file"

  # Output absolute path
  (cd "$OUTPUT_DIR" && pwd)

  # Exit with appropriate code
  if [ "$INTERRUPTED" -eq 1 ]; then
    exit 130
  fi
  exit 0
}

main "$@"
