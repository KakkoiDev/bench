#!/bin/sh
# bench - Minimal benchmarking CLI
# POSIX-compliant shell script (dash-compatible)

set -e

VERSION="1.0.0"
SCHEMA_VERSION="1.0"

# Global state for signal handling
INTERRUPTED=0
RUNS_COMPLETED=0
OUTPUT_DIR=""

# Error handling
error() {
  echo "Error: $1" >&2
  exit 1
}

# Show version
show_version() {
  echo "bench v${VERSION}"
  exit 0
}

# Show help
show_help() {
  cat << 'EOF'
Usage: bench [OPTIONS] COMMAND

Minimal benchmarking CLI - Run commands multiple times and capture structured data.

Options:
  --runs N          Number of runs (default: 10)
  --name NAME       Named group (optional, auto-generated from command)
  --message TEXT    Message describing this run (optional)
  --quiet           No progress output

  --pid PID         Monitor process by PID
  --port PORT       Monitor process by port

  --help            Show this help
  --version         Show version

Examples:
  bench --runs 10 "curl localhost:8080"
  bench --runs 20 --name "api-v1" --message "baseline" "curl localhost/api"
  bench --runs 50 --pid 12345 "curl localhost:8080"

Output:
  Results saved to: ./bench-results/<name>/<timestamp-pid>/
    - benchmark.json (all metrics)
    - runs/*.log (individual run outputs)

More info:
  https://github.com/KakkoiDev/bench
  https://github.com/KakkoiDev/bench/issues

EOF
  exit 0
}

# Signal handler for SIGINT/SIGTERM (invoked via trap)
# shellcheck disable=SC2329
handle_interrupt() {
  INTERRUPTED=1
}

# Get current time in seconds with microsecond precision
get_time() {
  perl -MTime::HiRes=time -e 'printf "%.6f\n", time()'
}

# Get ISO 8601 timestamp with milliseconds
get_iso_timestamp() {
  perl -MTime::HiRes=gettimeofday -MPOSIX=strftime -e '
    my ($s, $us) = gettimeofday();
    my $ms = int($us / 1000);
    print strftime("%Y-%m-%dT%H:%M:%S", localtime($s)) . sprintf(".%03d", $ms) . "\n";
  '
}

# Normalize bc output to always have leading zero
bc_normalize() {
  echo "$1" | bc | sed 's/^\./0./; s/^-\./-0./'
}

# Generate auto-name from command
# Algorithm: Remove quotes/special chars → lowercase → spaces to dashes → remove consecutive dashes → truncate 50 → trim trailing dashes
# Falls back to "benchmark" if result is empty (e.g., command is all special chars)
generate_name() {
  name=$(echo "$1" | \
    tr -cd 'a-zA-Z0-9 -' | \
    tr '[:upper:]' '[:lower:]' | \
    tr ' ' '-' | \
    sed 's/--*/-/g' | \
    cut -c1-50 | \
    sed 's/-$//')
  if [ -z "$name" ]; then
    echo "benchmark"
  else
    echo "$name"
  fi
}

# Check dependencies
check_dependencies() {
  # Check for perl
  if ! command -v perl >/dev/null 2>&1; then
    error "Required dependency 'perl' not found. Please install perl."
  fi

  # Check for bc
  if ! command -v bc >/dev/null 2>&1; then
    error "Required dependency 'bc' not found. Please install bc."
  fi

  # Check for Time::HiRes module
  if ! perl -MTime::HiRes -e 'exit 0' 2>/dev/null; then
    error "Required Perl module 'Time::HiRes' not found. Please install libtime-hires-perl or equivalent."
  fi
}

# Get process stats (CPU%, memory in MB) using ps
# Returns: "cpu_percent memory_mb" or empty if process not found
get_process_stats() {
  pid="$1"
  if [ -z "$pid" ] || ! kill -0 "$pid" 2>/dev/null; then
    echo ""
    return
  fi
  # ps output: %CPU %MEM RSS (in KB)
  # Convert RSS to MB
  stats=$(ps -p "$pid" -o %cpu=,%mem=,rss= 2>/dev/null | tail -1)
  if [ -n "$stats" ]; then
    cpu=$(echo "$stats" | awk '{print $1}')
    rss_kb=$(echo "$stats" | awk '{print $3}')
    mem_mb=$(echo "scale=2; $rss_kb / 1024" | bc)
    echo "$cpu $mem_mb"
  else
    echo ""
  fi
}

# Resolve port to PID using lsof (with timeout to prevent hanging)
resolve_port_to_pid() {
  port="$1"
  # Use timeout if available (3 seconds max)
  timeout_cmd=""
  if command -v timeout >/dev/null 2>&1; then
    timeout_cmd="timeout 3"
  fi

  if command -v lsof >/dev/null 2>&1; then
    $timeout_cmd lsof -ti :"$port" -sTCP:LISTEN 2>/dev/null | head -1
  elif command -v ss >/dev/null 2>&1; then
    # Fallback to ss
    $timeout_cmd ss -tlnp 2>/dev/null | grep ":$port " | sed -n 's/.*pid=\([0-9]*\).*/\1/p' | head -1
  else
    echo ""
  fi
}

# Main entry point
main() {
  # Default values
  RUNS=10
  NAME=""
  MESSAGE=""
  QUIET=0
  MONITOR_PID=""
  MONITOR_PORT=""
  COMMAND=""

  # Parse arguments
  while [ $# -gt 0 ]; do
    case "$1" in
      --version)
        show_version
        ;;
      --help)
        show_help
        ;;
      --runs)
        shift
        if [ -z "$1" ]; then
          error "--runs requires an argument"
        fi
        # Validate numeric
        case "$1" in
          ''|*[!0-9]*)
            error "--runs requires a numeric argument"
            ;;
        esac
        # Validate positive
        if [ "$1" -le 0 ]; then
          error "--runs must be a positive number (at least 1)"
        fi
        # Pre-flight disk space check for large runs (estimate 10MB per run)
        if [ "$1" -gt 10000 ]; then
          # Get available disk space in KB
          available_kb=$(df -k . 2>/dev/null | awk 'NR==2 {print $4}')
          if [ -n "$available_kb" ]; then
            # Estimate needed: runs * 10MB = runs * 10240 KB
            needed_kb=$((${1} * 10240 / 1000))
            if [ "$available_kb" -lt "$needed_kb" ]; then
              error "Insufficient disk space for $1 runs (need ~$((needed_kb / 1024))MB, have ~$((available_kb / 1024))MB)"
            fi
          fi
        fi
        RUNS="$1"
        shift
        ;;
      --name)
        shift
        if [ -z "$1" ]; then
          error "--name requires an argument"
        fi
        # Validate length (max 255 chars)
        if [ "${#1}" -gt 255 ]; then
          error "--name must be 255 characters or less"
        fi
        NAME="$1"
        shift
        ;;
      --message)
        shift
        if [ -z "$1" ]; then
          error "--message requires an argument"
        fi
        # Validate length (max 1000 chars)
        if [ "${#1}" -gt 1000 ]; then
          error "--message must be 1000 characters or less"
        fi
        MESSAGE="$1"
        shift
        ;;
      --quiet)
        QUIET=1
        shift
        ;;
      --pid)
        shift
        if [ -z "$1" ]; then
          error "--pid requires an argument"
        fi
        # Validate numeric
        case "$1" in
          ''|*[!0-9]*)
            error "--pid requires a numeric argument"
            ;;
        esac
        MONITOR_PID="$1"
        shift
        ;;
      --port)
        shift
        if [ -z "$1" ]; then
          error "--port requires an argument"
        fi
        # Validate numeric
        case "$1" in
          ''|*[!0-9]*)
            error "--port requires a numeric argument"
            ;;
        esac
        MONITOR_PORT="$1"
        shift
        ;;
      --)
        shift
        COMMAND="$*"
        break
        ;;
      -*)
        error "Unknown option: $1"
        ;;
      *)
        COMMAND="$*"
        break
        ;;
    esac
  done

  # Validate command provided
  if [ -z "$COMMAND" ]; then
    error "Command required. Use --help for usage information."
  fi

  # Check dependencies
  check_dependencies

  # Resolve --port to PID if specified
  if [ -n "$MONITOR_PORT" ]; then
    MONITOR_PID=$(resolve_port_to_pid "$MONITOR_PORT")
    if [ -z "$MONITOR_PID" ]; then
      error "No process found listening on port $MONITOR_PORT"
    fi
  fi

  # Validate PID exists before starting benchmark
  if [ -n "$MONITOR_PID" ]; then
    if ! kill -0 "$MONITOR_PID" 2>/dev/null; then
      error "Process $MONITOR_PID does not exist"
    fi
  fi

  # Auto-generate name if not provided
  if [ -z "$NAME" ]; then
    NAME=$(generate_name "$COMMAND")
  fi

  # Create output directory: ./bench-results/<name>/YYYYMMDD-HHMMSS-PID/
  timestamp=$(date '+%Y%m%d-%H%M%S')
  OUTPUT_DIR="./bench-results/${NAME}/${timestamp}-$$"
  mkdir -p "$OUTPUT_DIR/runs"

  # Setup signal handlers
  trap 'handle_interrupt' INT TERM

  # Disable exit on error for benchmark loop (we track failures ourselves)
  set +e

  # Run benchmark loop
  run_num=1
  times_file=$(mktemp)
  exit_codes_file=$(mktemp)
  runs_file=$(mktemp)
  server_metrics_file=$(mktemp)

  # Capture initial server metrics for leak detection
  if [ -n "$MONITOR_PID" ]; then
    initial_stats=$(get_process_stats "$MONITOR_PID")
    if [ -n "$initial_stats" ]; then
      initial_mem=$(echo "$initial_stats" | awk '{print $2}')
    else
      initial_mem=0
    fi
  fi

  if [ "$QUIET" -eq 0 ]; then
    echo "Running '$COMMAND' $RUNS times..." >&2
  fi

  while [ "$run_num" -le "$RUNS" ] && [ "$INTERRUPTED" -eq 0 ]; do
    if [ "$QUIET" -eq 0 ]; then
      printf "\r  Run %d/%d" "$run_num" "$RUNS" >&2
    fi

    # Capture timestamps and timing
    start_iso=$(get_iso_timestamp)
    start_time=$(get_time)

    # Run command in background to allow signal handling
    # Capture stdout and stderr separately
    stdout_file="$OUTPUT_DIR/runs/${run_num}.stdout"
    stderr_file="$OUTPUT_DIR/runs/${run_num}.stderr"
    sh -c "$COMMAND" > "$stdout_file" 2> "$stderr_file" &
    cmd_pid=$!
    wait $cmd_pid 2>/dev/null
    cmd_exit=$?

    end_time=$(get_time)
    end_iso=$(get_iso_timestamp)

    # Check for interrupt after each run
    if [ "$INTERRUPTED" -eq 1 ]; then
      # Kill any remaining child process
      kill $cmd_pid 2>/dev/null || true
      break
    fi

    # Calculate durations
    duration_ms=$(bc_normalize "scale=6; ($end_time - $start_time) * 1000")
    duration_sec=$(bc_normalize "scale=6; $end_time - $start_time")

    # Get output sizes
    stdout_bytes=$(wc -c < "$stdout_file")
    stderr_bytes=$(wc -c < "$stderr_file")

    # Combine stdout/stderr into single log for backwards compatibility
    cat "$stdout_file" "$stderr_file" > "$OUTPUT_DIR/runs/${run_num}.log"

    # Capture server metrics if monitoring
    run_cpu=""
    run_mem=""
    if [ -n "$MONITOR_PID" ]; then
      server_stats=$(get_process_stats "$MONITOR_PID")
      if [ -n "$server_stats" ]; then
        run_cpu=$(echo "$server_stats" | awk '{print $1}')
        run_mem=$(echo "$server_stats" | awk '{print $2}')
        echo "$run_cpu $run_mem" >> "$server_metrics_file"
      fi
    fi

    # Store per-run data as JSON line
    server_field=""
    if [ -n "$run_cpu" ] && [ -n "$run_mem" ]; then
      server_field=",\"server\":{\"cpu_percent\":$run_cpu,\"memory_mb\":$run_mem}"
    fi
    echo "{\"run_number\":$run_num,\"exit_code\":$cmd_exit,\"start\":\"$start_iso\",\"end\":\"$end_iso\",\"duration_seconds\":$duration_sec,\"duration_ms\":$duration_ms,\"stdout_bytes\":$stdout_bytes,\"stderr_bytes\":$stderr_bytes$server_field}" >> "$runs_file"

    # Store results for statistics
    echo "$duration_ms" >> "$times_file"
    echo "$cmd_exit" >> "$exit_codes_file"

    RUNS_COMPLETED=$run_num
    run_num=$((run_num + 1))
  done

  if [ "$QUIET" -eq 0 ]; then
    echo "" >&2
  fi

  # Re-enable exit on error
  set -e

  # Calculate statistics
  runs_successful=0
  runs_failed=0
  while IFS= read -r code; do
    if [ "$code" -eq 0 ]; then
      runs_successful=$((runs_successful + 1))
    else
      runs_failed=$((runs_failed + 1))
    fi
  done < "$exit_codes_file"

  # Calculate timing statistics
  if [ "$RUNS_COMPLETED" -gt 0 ]; then
    # Sort times for median/percentiles
    sorted_times=$(sort -n "$times_file")

    # Min/Max
    time_min=$(echo "$sorted_times" | head -1)
    time_max=$(echo "$sorted_times" | tail -1)

    # Mean
    time_sum=$(awk '{sum+=$1} END {printf "%.6f", sum}' "$times_file")
    time_mean=$(bc_normalize "scale=6; $time_sum / $RUNS_COMPLETED")

    # Median
    mid=$((RUNS_COMPLETED / 2))
    if [ $((RUNS_COMPLETED % 2)) -eq 0 ]; then
      val1=$(echo "$sorted_times" | sed -n "${mid}p")
      val2=$(echo "$sorted_times" | sed -n "$((mid + 1))p")
      time_median=$(bc_normalize "scale=6; ($val1 + $val2) / 2")
    else
      time_median=$(echo "$sorted_times" | sed -n "$((mid + 1))p")
    fi

    # Standard deviation (sample stddev with n-1 denominator)
    # Formula: sqrt(sum((x - mean)^2) / (n - 1))
    if [ "$RUNS_COMPLETED" -gt 1 ]; then
      sum_sq_diff=$(awk -v mean="$time_mean" '{diff=$1-mean; sum+=diff*diff} END {printf "%.6f", sum}' "$times_file")
      time_stddev=$(bc_normalize "scale=6; sqrt($sum_sq_diff / ($RUNS_COMPLETED - 1))")
    else
      time_stddev=0
    fi

    # Percentiles using nearest rank method
    # Formula: rank = ceil(percentile * n)
    # p95
    p95_rank=$(echo "scale=0; ($RUNS_COMPLETED * 95 + 99) / 100" | bc)
    [ "$p95_rank" -gt "$RUNS_COMPLETED" ] && p95_rank=$RUNS_COMPLETED
    time_p95=$(echo "$sorted_times" | sed -n "${p95_rank}p")

    # p99
    p99_rank=$(echo "scale=0; ($RUNS_COMPLETED * 99 + 99) / 100" | bc)
    [ "$p99_rank" -gt "$RUNS_COMPLETED" ] && p99_rank=$RUNS_COMPLETED
    time_p99=$(echo "$sorted_times" | sed -n "${p99_rank}p")
  else
    time_min=0
    time_max=0
    time_mean=0
    time_median=0
    time_stddev=0
    time_p95=0
    time_p99=0
  fi

  # Calculate success rate
  if [ "$RUNS_COMPLETED" -gt 0 ]; then
    success_rate=$(bc_normalize "scale=2; $runs_successful * 100 / $RUNS_COMPLETED")
  else
    success_rate=0
  fi

  # Calculate server metrics if monitoring
  server_json=""
  if [ -n "$MONITOR_PID" ] && [ -s "$server_metrics_file" ]; then
    # Get final memory for leak detection
    final_stats=$(get_process_stats "$MONITOR_PID")
    if [ -n "$final_stats" ]; then
      final_mem=$(echo "$final_stats" | awk '{print $2}')
    else
      final_mem="$initial_mem"
    fi
    mem_delta=$(bc_normalize "scale=2; $final_mem - $initial_mem")

    # Calculate CPU stats
    cpu_mean=$(awk '{sum+=$1; count++} END {if(count>0) printf "%.2f", sum/count; else print "0"}' "$server_metrics_file")
    cpu_min=$(awk 'NR==1{min=$1} {if($1<min)min=$1} END{printf "%.2f", min}' "$server_metrics_file")
    cpu_max=$(awk 'NR==1{max=$1} {if($1>max)max=$1} END{printf "%.2f", max}' "$server_metrics_file")

    # Calculate memory stats
    mem_mean=$(awk '{sum+=$2; count++} END {if(count>0) printf "%.2f", sum/count; else print "0"}' "$server_metrics_file")
    mem_min=$(awk 'NR==1{min=$2} {if($2<min)min=$2} END{printf "%.2f", min}' "$server_metrics_file")
    mem_max=$(awk 'NR==1{max=$2} {if($2>max)max=$2} END{printf "%.2f", max}' "$server_metrics_file")

    server_json=",
  \"server\": {
    \"pid\": $MONITOR_PID,
    \"cpu\": {
      \"unit\": \"percent\",
      \"mean\": $cpu_mean,
      \"min\": $cpu_min,
      \"max\": $cpu_max
    },
    \"memory\": {
      \"unit\": \"megabytes\",
      \"mean\": $mem_mean,
      \"min\": $mem_min,
      \"max\": $mem_max,
      \"initial\": $initial_mem,
      \"final\": $final_mem,
      \"delta\": $mem_delta
    }
  }"
  fi

  # Build runs array from temp file
  runs_json="["
  first=1
  while IFS= read -r line; do
    if [ "$first" -eq 1 ]; then
      first=0
    else
      runs_json="$runs_json,"
    fi
    runs_json="$runs_json
    $line"
  done < "$runs_file"
  runs_json="$runs_json
  ]"

  # Generate JSON output
  cat > "$OUTPUT_DIR/benchmark.json" << ENDJSON
{
  "schema_version": "$SCHEMA_VERSION",
  "tool": "bench",
  "tool_version": "$VERSION",
  "name": "$NAME",
  "message": "$MESSAGE",
  "command": "$COMMAND",
  "runs_requested": $RUNS,
  "runs_completed": $RUNS_COMPLETED,
  "runs_successful": $runs_successful,
  "runs_failed": $runs_failed,
  "success_rate": $success_rate,
  "interrupted": $([ "$INTERRUPTED" -eq 1 ] && echo "true" || echo "false"),
  "timing": {
    "unit": "milliseconds",
    "min": $time_min,
    "max": $time_max,
    "mean": $time_mean,
    "median": $time_median,
    "stddev": $time_stddev,
    "p95": $time_p95,
    "p99": $time_p99
  },
  "environment": {
    "os": "$(uname -s)",
    "shell": "$SHELL",
    "pwd": "$PWD"
  },
  "runs": $runs_json$server_json
}
ENDJSON

  # Cleanup temp files
  rm -f "$times_file" "$exit_codes_file" "$runs_file" "$server_metrics_file"

  # Output absolute path
  (cd "$OUTPUT_DIR" && pwd)

  # Exit with appropriate code
  if [ "$INTERRUPTED" -eq 1 ]; then
    exit 130
  fi
  exit 0
}

main "$@"
